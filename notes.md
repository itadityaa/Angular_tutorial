# TypeScript and Angular

TypeScript (TS) is a superset of JavaScript (JS). It is generally recommended to use TS with modern frameworks because of the advantages it offers over JS. TS is just a development tool, and not a language that runs in the web browser. TS is ultimately converted into JS, and then the browser runs JS.

**Angular** is written in TS.

To install Angular:

1. Install Node.js
2. Install Angular CLI: `npm install -g @angular/cli`

# Websites vs. Web Applications

## Website

- **Definition**: A website is a collection of static or dynamic web pages that provide content and information to users.
- **Purpose**: Primarily informational, providing content such as text, images, videos, and other multimedia. Examples include blogs, news sites, personal pages, and company websites.
- **Functionality**: Usually limited interactivity. Users typically read or view content without extensive interaction. May include basic forms (e.g., contact forms) or comment sections.
- **Technology**: Often built using HTML, CSS, and JavaScript. May use a content management system (CMS) like WordPress, Joomla, or Drupal. Backend technologies like PHP, Python, Ruby, or ASP.NET can be used to manage dynamic content.
- **User Interaction**: Minimal user interaction. Primary goal is to deliver information.

## Web Application

- **Definition**: A web application is an interactive software application that runs on a web server and is accessed through a web browser.
- **Purpose**: Designed for interactive user engagement and specific tasks. Examples include online banking, email clients, social media platforms, e-commerce sites, and productivity tools (e.g., Google Docs).
- **Functionality**: High level of interactivity and functionality. Users perform various tasks such as submitting forms, manipulating data, and triggering server-side processes. Often includes features like authentication, user roles, data processing, and real-time updates.
- **Technology**: Often uses more advanced and diverse technologies. Frontend: Modern JavaScript frameworks like React, Angular, or Vue.js. Backend: Technologies like Node.js, Django, Ruby on Rails, or Java Spring. Uses APIs for server-side communication and data exchange (REST, GraphQL).
- **User Interaction**: High user interaction with complex user interfaces and workflows. Provides a more app-like experience within a web browser.

## Key Differences

| Feature          | Website                                   | Web Application                               |
| ---------------- | ----------------------------------------- | --------------------------------------------- |
| Definition       | Collection of static or dynamic web pages | Interactive software application              |
| Purpose          | Primarily informational                   | Designed for interactive user engagement      |
| Functionality    | Limited interactivity                     | High level of interactivity and functionality |
| Technology       | HTML, CSS, JavaScript, CMS                | Advanced JS frameworks, server-side tech      |
| User Interaction | Minimal                                   | High user interaction                         |

## Examples

- **Website**: Wikipedia, BBC News
- **Web Application**: Gmail, Facebook, Amazon

# Static Website vs. Server-Side Rendering (SSR) Website

## Static Website

- **Definition**: A static website consists of web pages with fixed content. Each page is a separate HTML file stored on the server.
- **Content Delivery**: Content is delivered exactly as stored. There is no dynamic content generation based on user interaction or data.
- **Generation**: Pages are typically created manually or using static site generators (e.g., Jekyll, Hugo, Gatsby). Content is pre-built and doesn’t change unless the source files are updated and redeployed.
- **Performance**: Typically very fast because content is pre-rendered and can be served directly from a content delivery network (CDN). No server-side processing is needed to generate the page content.
- **Complexity**: Simpler to host and deploy. Requires minimal server resources since no backend processing is involved. Ideal for sites with content that doesn’t change frequently (e.g., personal blogs, documentation sites).
- **Scalability**: Highly scalable due to minimal server load. CDNs can easily distribute the content globally.

## Server-Side Rendering (SSR) Website

- **Definition**: A server-side rendering website generates HTML content dynamically on the server in response to user requests.
- **Content Delivery**: Content is generated on-the-fly based on user interactions, data, and other factors. Each request may result in a different HTML response.
- **Generation**: Pages are generated by server-side code (e.g., Node.js, Ruby on Rails, Django, ASP.NET). Content can be customized for each user, incorporating data from databases, APIs, and user sessions.
- **Performance**: Can be slower compared to static websites due to server-side processing required to generate the HTML. Techniques like caching and using faster backend frameworks can mitigate performance issues.
- **Complexity**: More complex to develop, host, and deploy. Requires server infrastructure and backend code to handle requests and generate responses. Suitable for dynamic applications where content changes frequently (e.g., e-commerce sites, social media platforms).
- **Scalability**: Can be more challenging to scale due to the need for server-side processing. Load balancing and horizontal scaling are often used to handle high traffic.

## Comparison

| Feature          | Static Website                             | Server-Side Rendering Website                |
| ---------------- | ------------------------------------------ | -------------------------------------------- |
| Content Delivery | Fixed content, pre-rendered                | Dynamic content, generated on-the-fly        |
| Generation       | Pre-built HTML files                       | HTML generated by server-side code           |
| Performance      | Very fast, minimal server load             | Potentially slower, depends on server load   |
| Complexity       | Simple to host and deploy                  | More complex, requires server infrastructure |
| Scalability      | Highly scalable with CDNs                  | More challenging, requires load balancing    |
| Ideal Use Cases  | Blogs, documentation, static content sites | E-commerce, social media, dynamic content    |

## Why Server-Side Rendering (SSR) is Preferred for SEO

Server-Side Rendering (SSR) is preferred for SEO (Search Engine Optimization) due to several reasons:

1. **Content Availability**: With SSR, the server generates the complete HTML content for each page on the server before sending it to the client. This means search engine crawlers can easily access and index the content, including meta tags, headings, and other important elements.

2. **Better Crawling and Indexing**: Search engine bots have an easier time crawling SSR-rendered pages since the content is available directly in the HTML response. This improves the chances of all content being properly indexed by search engines.

3. **Page Loading Time**: SSR can potentially improve page loading times since the initial HTML content is sent from the server, reducing the time needed for initial rendering. Faster loading times are crucial for SEO, as search engines prioritize websites with better performance.

4. **JavaScript Execution**: Some search engine crawlers may have limited capabilities in executing JavaScript, which is commonly used in client-side rendering (CSR) frameworks. SSR ensures that the content is rendered on the server side, bypassing any potential issues with JavaScript execution.

5. **Social Media Sharing**: When users share links on social media platforms, the shared content is often based on the initial HTML response. SSR ensures that the shared content accurately represents the page, improving the visibility and engagement on social media.

6. **Consistency**: SSR provides a consistent experience for both users and search engine crawlers. Since the content is pre-rendered on the server, there are fewer chances of discrepancies between the client-side and server-side versions of the page.

In summary, Server-Side Rendering (SSR) is preferred for SEO because it ensures that web pages are easily accessible, crawlable, and indexable by search engines. By providing complete and optimized HTML content directly from the server, SSR helps improve search engine rankings and visibility.

# Modules in Angular

In Angular, modules are a fundamental concept that help organize and manage the application’s structure. They allow you to break down an application into smaller, reusable pieces, making it easier to develop, maintain, and test.

## What is an Angular Module?

An Angular module, also known as an NgModule, is a class decorated with the `@NgModule` decorator. This decorator provides metadata that Angular uses to organize the application. An NgModule can contain components, directives, pipes, and services that are related to a specific feature or functionality of the application.

## Key Elements of an NgModule

An NgModule has several key properties defined in the `@NgModule` decorator:

- **declarations**: This property lists the components, directives, and pipes that belong to this module.
- **imports**: This property specifies the other modules whose exported classes are needed by the components in this module.
- **providers**: This property registers services that the module uses. Services registered here are available to all the components within the module.
- **bootstrap**: This property lists the components that should be instantiated when this module is bootstrapped. Typically used in the root module.
- **exports**: This property makes certain components, directives, and pipes available to other modules that import this module.

## Example of an Angular Module

```typescript
import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { AppComponent } from "./app.component";
import { FormsModule } from "@angular/forms";
import { HttpClientModule } from "@angular/common/http";
import { MyFeatureModule } from "./my-feature/my-feature.module";

@NgModule({
  declarations: [
    AppComponent, // Declare components, directives, and pipes here
  ],
  imports: [
    BrowserModule, // Import essential Angular modules
    FormsModule,
    HttpClientModule,
    MyFeatureModule, // Import feature modules
  ],
  providers: [],
  bootstrap: [AppComponent], // Bootstrap the root component
})
export class AppModule {}
```

# Types of Modules

- **Root Module**: This is the main module of the application, typically named `AppModule`. It bootstraps the root component (often named `AppComponent`) and imports essential Angular modules.

- **Feature Modules**: These modules are used to organize code related to specific features or sections of the application. They help in dividing the application into smaller, manageable parts. Examples include `UserModule`, `AdminModule`, etc.

- **Shared Module**: This module contains common components, directives, and pipes that are used across multiple modules. It helps in avoiding code duplication and promoting reusability.

- **Core Module**: This module typically contains singleton services that are used throughout the application. It is imported only in the root module to ensure that the services are singletons.

# Advantages of Using Modules

- **Organized Structure**: Modules help in organizing the application into cohesive blocks of functionality, making the codebase more maintainable and readable.
- **Reusability**: Modules promote reusability of components, directives, and services across different parts of the application.
- **Lazy Loading**: Modules can be loaded lazily, which means they are loaded only when needed. This improves the initial loading time of the application.
- **Scalability**: Modules make it easier to scale the application by allowing developers to add new features as separate modules without affecting the existing functionality.
- **Dependency Management**: Modules provide a way to manage dependencies effectively, ensuring that each module gets the dependencies it needs without conflicts.

In summary, modules are a crucial part of Angular's architecture, providing a way to organize, manage, and scale an application efficiently. By dividing the application into smaller, reusable pieces, modules make development more structured and maintainable.

# To start a new angluar project

- Open terminal and write the following command: `ng new {project_name}`
- Choose the type of CSS: CSS, SCSS, SASS, LESS

## Difference Between CSS, SCSS, SASS, and LESS

### CSS (Cascading Style Sheets)

CSS is a styling language used to define the presentation of HTML elements on a web page. It provides a straightforward syntax for styling web pages but lacks some features like variables and nested rules.

Example:

```css
/* CSS Example */
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
}
```

### SCSS (Sassy CSS)

SCSS is a superset of CSS that adds features like variables, nesting, and mixins while maintaining compatibility with CSS syntax. SCSS files use the .scss extension.

Example:

```scss
/* SCSS Example */

$primary-color: #007bff;

body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  color: $primary-color;
}
```

### SASS

SASS is an older version of SCSS, with a slightly different syntax that is indentation-based rather than using curly braces and semicolons. SASS files use the `.sass` extension.

**Example:**

```sass
/* SASS Example */
$primary-color: #007bff;

body
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  color: $primary-color;

```

### LESS

LESS is another CSS preprocessor that extends CSS with features like variables, mixins, and nested rules. Its syntax is similar to CSS but with added functionality.

**Example:**

```less
/* LESS Example */
@primary-color: #007bff;

body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  color: @primary-color;
}
```

In summary, while CSS is the standard styling language for web development, SCSS, SASS, and LESS are CSS preprocessors that enhance CSS with additional features, making styling more efficient and maintainable.
